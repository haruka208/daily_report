## ・取り組んだ課題一覧
- Python
- スッキリわかるSQL入門ドリル
- 達人に学ぶDB設計徹底指南書

## ・わかったこと
- - その他：パーティション　インデックスよりもカーディナリティが低い列に向く
- - ヒント句　強制的に実行計画を変える機能
- - パラレルクエリ　通常シングルコアで実行されるクエリの処理をマルチコア化する方法　リソースが潤沢に余っている場合に限られるチューニング手段
- - オンメモリ　パラレルクエリとよく似た特性、ストレージI/Oがクエリのボトルネックになっていることが前提条件　データベースのメモリが潤沢に余っている場合に取りうるチューニング手段
- ビットマップインデックス　カーディナリティが低い列に対しても検索性能がいい、インデックスそのもののサイズも小さくなる　更新時の性能が悪い
- ハッシュインデックス　データの分散に利用、等値計算(=)において非常に高速な計算を実現　等値計算以外では利用できない
- 論理設計のアンチパターン
- - 非スカラ値（第一正規系未満）
- - ダブルミーニング　一つの列に複数の意味が混在
- - 単一参照テーブル　一つのテーブルに複数のマスタテーブルが混在　最もグレーノウハウに近い設計方法
- - テーブル分割　パフォーマンス向上を目的として実施されることが多く、目的がはっきりしていることもあり、それほどアンチパターンとは認識されていない
- - 集約　テーブル分割の代替案（データマートの作成orサマリテーブルの作成（集約関数によってレコードを集約した状態で保持））
- - 不適切なキー　可変長文字列(VARCHAR)はキーに不向き
- - ダブルマスタ　同じ役割を果たすマスターテーブルが２つ存在する
- - ゾンビマート、多段マート
- 論理設計のグレーノウハウ
- - 代理キー　入力データに最初から存在している自然キーの「代理」として新たに追加するコード
- - → 解決策としてタイムスタンプorインターバル
- - 列持ちテーブル（繰り返し項目テーブル）　基本的には「行持ち」のテーブル構成を採用すべき　行持ちと列持ちの変換はSQL一発で可能なので、最初は拡張性の高い行持ちテーブルでデータを保持するのが◎
- - アドホック（場当たり的）な集計キー
- - 多段ビュー　ビューの使用は原則として１段に留めておくようにする　KISSの原則(Keep It Simple, Stupid)
- オートナンバリングの実装方法
- - DB側で実装　シーケンスとID列では、シーケンスの方がより柔軟で拡張性に富む
- - アプリケーション側で実装　採番テーブルの利用（お勧めできない）
- データクレンジング　データベース設計に先立って行う必要がある
- - 一意キーの設定
- - 名寄せ　人名や企業名の表記揺れを解消して名称を統一する

## ・感じたこと
- DBは論理設計のアンチパターンとグレーノウハウを学んだ
色々なパターンを学びましたが、一度読んだだけではあまり整理できていないので、実際に設計する時にまた考えたいと思う

## ・次やること
- Python
- スッキリわかるSQL入門ドリル
- 達人に学ぶDB設計徹底指南書


## ・学習時間
- today:  7h
- total  : 624.75h